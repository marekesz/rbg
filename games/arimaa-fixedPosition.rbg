// Arimaa with a fixed initial position
// -- There is a predefined chess-like setup.
// -- The state after the move must be different.
// -- No rule forbidding a state repeated three times.
// -- Play is limited to 200 turns.

#colorPieces(color) = color~Elephant, color~Camel, color~Horse, color~Dog, color~Cat, color~Rabbit
#players = gold(100), silver(100)
#pieces = colorPieces(gold), colorPieces(silver), goldRabbitSecond, silverRabbitSecond, empty
#variables = turnCount(200), steps(4), changed(1)

#chessLayer = [[silverHorse ,silverCat   ,silverDog   ,silverCamel ,silverElephant,silverDog   ,silverCat   ,silverHorse]
         [silverRabbit,silverRabbit,silverRabbit,silverRabbit,silverRabbit  ,silverRabbit,silverRabbit,silverRabbit]
         [empty     , empty     , empty     , empty     , empty     , empty     , empty     , empty     ]
         [empty     , empty     , empty     , empty     , empty     , empty     , empty     , empty     ]
         [empty     , empty     , empty     , empty     , empty     , empty     , empty     , empty     ]
         [empty     , empty     , empty     , empty     , empty     , empty     , empty     , empty     ]
         [goldRabbit, goldRabbit, goldRabbit,goldRabbit,goldRabbit  ,goldRabbit ,goldRabbit ,goldRabbit ]
         [goldHorse , goldCat   , goldDog   ,goldCamel ,goldElephant,goldDog    ,goldCat    ,goldHorse  ]]
#board = cuboid(up,down,left,right,backLayer,frontLayer, chessLayer chessLayer)

#anySquare = (left* + right*)(up* + down*)
#anyNeighborSquare = (left + right + up + down)

#setupPiece(color; piece; backward) = (->color anySquare {! backward^2} {empty} [color~piece])
#setupPlayer(color; backward) = setupPiece(color; Elephant; backward)
                                setupPiece(color; Camel; backward)
                                setupPiece(color; Horse; backward)^2
                                setupPiece(color; Dog; backward)^2
                                setupPiece(color; Cat; backward)^2
                                setupPiece(color; Rabbit; backward)^8

#fireTrap = (
      {colorPieces(gold)} ({? anyNeighborSquare {colorPieces(gold)}} + {! anyNeighborSquare {colorPieces(gold)}} [empty] [$ changed = 1])
    + {colorPieces(silver)} ({? anyNeighborSquare {colorPieces(silver)}} + {! anyNeighborSquare {colorPieces(silver)}} [empty] [$ changed = 1])
    + {empty}
  )

#fireTraps = (
    anySquare left^7 up^7
    right^2 down^2 fireTrap
    right^3 fireTrap
    down^3 fireTrap
    left^3 fireTrap
  )

#isFrozen(color; oppColor) = (
    {! anyNeighborSquare {colorPieces(color)}}
    {?
        {color~Camel} anyNeighborSquare {oppColor~Elephant}
	    + {color~Horse} anyNeighborSquare {oppColor~Elephant,oppColor~Camel}
	    + {color~Dog} anyNeighborSquare {oppColor~Elephant,oppColor~Camel,oppColor~Horse}
	    + {color~Cat} anyNeighborSquare {oppColor~Elephant,oppColor~Camel,oppColor~Horse,oppColor~Dog}
	    + {color~Rabbit} anyNeighborSquare {oppColor~Elephant,oppColor~Camel,oppColor~Horse,oppColor~Dog,oppColor~Cat}
	  }
  )

#basicMoveRabbit(color; oppColor; forward) = (
    {color~Rabbit} [empty]
    (
        left {empty} [color~Rabbit]
      + right {empty} [color~Rabbit]
      + forward {empty} [color~Rabbit] [$ changed = 1]
    )
  )

#basicMovePiece(color; piece) = (
    {color~piece} [empty]
    (
        left {empty} [color~piece]
      + right {empty} [color~piece]
      + up {empty} [color~piece]
      + down {empty} [color~piece]
    )
  )

#basicMove(color; oppColor; forward) = (
    (
        basicMovePiece(color; Elephant)
      + basicMovePiece(color; Camel)
      + basicMovePiece(color; Horse)
      + basicMovePiece(color; Dog)
      + basicMovePiece(color; Cat)
      + basicMoveRabbit(color; oppColor; forward)
    )
  )

#displace(color; dir) = (
      {color~Rabbit} [empty] dir {empty} [color~Rabbit]
    + {color~Cat} [empty] dir {empty} [color~Cat]
    + {color~Dog} [empty] dir {empty} [color~Dog]
    + {color~Horse} [empty] dir {empty} [color~Horse]
    + {color~Camel} [empty] dir {empty} [color~Camel]
    + {color~Elephant} [empty] dir {empty} [color~Elephant]
  )

#pushMovePiece(color; piece; weakerPieces; oppColor) = (
    (
        left weakerPieces (displace(oppColor; left) right + displace(oppColor; up) down + displace(oppColor; down) up)
      + right weakerPieces (displace(oppColor; right) left + displace(oppColor; up) down + displace(oppColor; down) up)
      + up weakerPieces (displace(oppColor; left) right + displace(oppColor; right) left + displace(oppColor; up) down)
      + down weakerPieces (displace(oppColor; left) right + displace(oppColor; right) left + displace(oppColor; down) up)
    ) [color~piece]
  )

#pullMovePiece(color; piece; weakerPieces; oppColor) = (
    (
        left {empty} [color~piece] right
      + right {empty} [color~piece] left
      + up {empty} [color~piece] down
      + down {empty} [color~piece] up   
    )
    (
        left weakerPieces displace(oppColor; right)
      + right weakerPieces displace(oppColor; left)
      + up weakerPieces displace(oppColor; down)
      + down weakerPieces displace(oppColor; up)    
    )
  )

#pushOrPullMovePiece(color; piece; weakerPieces; oppColor) = (
    {color~piece} [empty] (
        pushMovePiece(color; piece; weakerPieces; oppColor)
      + pullMovePiece(color; piece; weakerPieces; oppColor)
    )
  )

#pushOrPullMove(color; oppColor) = (
      pushOrPullMovePiece(color; Elephant; {oppColor~Camel,oppColor~Horse,oppColor~Dog,oppColor~Cat,oppColor~Rabbit}; oppColor)
    + pushOrPullMovePiece(color; Camel; {oppColor~Horse,oppColor~Dog,oppColor~Cat,oppColor~Rabbit}; oppColor)
    + pushOrPullMovePiece(color; Horse; {oppColor~Dog,oppColor~Cat,oppColor~Rabbit}; oppColor)
    + pushOrPullMovePiece(color; Dog; {oppColor~Cat,oppColor~Rabbit}; oppColor)
    + pushOrPullMovePiece(color; Cat; {oppColor~Rabbit}; oppColor)
  )

#forEachPiece(actionBegin; actionEnd) = (
      {empty} actionBegin empty actionEnd
    + {goldElephant} actionBegin goldElephant actionEnd
    + {goldCamel} actionBegin goldCamel actionEnd
    + {goldHorse} actionBegin goldHorse actionEnd
    + {goldDog} actionBegin goldDog actionEnd
    + {goldCat} actionBegin goldCat actionEnd
    + {goldRabbit} actionBegin goldRabbitSecond actionEnd
    + {silverElephant} actionBegin silverElephant actionEnd
    + {silverCamel} actionBegin silverCamel actionEnd
    + {silverHorse} actionBegin silverHorse actionEnd
    + {silverDog} actionBegin silverDog actionEnd
    + {silverCat} actionBegin silverCat actionEnd
    + {silverRabbit} actionBegin silverRabbitSecond actionEnd
  )
#isDifferentPieceInConfigurations = {! forEachPiece(backLayer {;})}
#isConfigurationDifferent = {? anySquare isDifferentPieceInConfigurations}
#isConfigurationSame = {! anySquare isDifferentPieceInConfigurations}
#copyConfiguration = (
    (anySquare isDifferentPieceInConfigurations ->> forEachPiece(backLayer [;]) frontLayer)*
    isConfigurationSame
  )

#checkWin = (
      {$ goldRabbit > 0} {$ silverRabbit > 0} {! anySquare {! down} {silverRabbit}} {! anySquare {! up} {goldRabbit}}
    + ({$ goldRabbit == 0} + {? anySquare {! down} {silverRabbit}}) [$ silver=100, gold=0] ->> {}
    + ({$ silverRabbit == 0} + {? anySquare {! up} {goldRabbit}}) [$ gold=100, silver=0] ->> {}
  )

#turn(color; oppColor; forward; backward) = (
    [$ steps = 4] [$ changed = 0]
    (
      {$ steps > 0} anySquare {colorPieces(color)} {! isFrozen(color; oppColor)} (   
          [$ steps = steps-1] basicMove(color; oppColor; forward)
        + [$ steps = steps-2] pushOrPullMove(color; oppColor)
      )
      fireTraps
      checkWin
    )*
    (
        {$ changed == 1} + {$ steps == 1} + {$ steps == 3}
      + {$ changed == 0} ({$ steps == 0} + {$ steps == 2}) isConfigurationDifferent
    )
    ->>
    [$ color=50, oppColor=50]
    ->>
    [$ turnCount = turnCount+1]
    [$ color=100, oppColor=0]
    ->>
    copyConfiguration
    -> oppColor
  )

#rules =
    copyConfiguration
    ->gold
    (
      turn(gold; silver; up; down)
      turn(silver; gold; down; up)
    )*
